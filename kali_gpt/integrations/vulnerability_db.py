"""Vulnerability Database Integration Module"""

import requests
import json
from pathlib import Path
from typing import Dict, List, Optional
from datetime import datetime, timedelta
import time

class VulnerabilityDatabase:
    """Integrates with vulnerability databases (NVD, CVE, ExploitDB)"""

    NVD_API_URL = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    CVE_API_URL = "https://cveawg.mitre.org/api/cve"
    EXPLOIT_DB_URL = "https://www.exploit-db.com"

    def __init__(self, config_manager):
        """Initialize vulnerability database integration"""
        self.config = config_manager
        self.db_config = config_manager.get("vulnerability_db", {})
        self.enabled = self.db_config.get("enabled", True)

        # Local cache
        self.cache_dir = Path(config_manager.config_dir) / "vuln_cache"
        self.cache_dir.mkdir(parents=True, exist_ok=True)
        self.cache_file = self.cache_dir / "vuln_cache.json"
        self.cache = self.load_cache()

        # Rate limiting
        self.last_request_time = 0
        self.min_request_interval = 1.0  # seconds

    def load_cache(self) -> Dict:
        """Load vulnerability cache from file"""
        if self.cache_file.exists():
            try:
                with open(self.cache_file, 'r') as f:
                    return json.load(f)
            except json.JSONDecodeError:
                return {}
        return {}

    def save_cache(self):
        """Save vulnerability cache to file"""
        with open(self.cache_file, 'w') as f:
            json.dump(self.cache, f, indent=2)

    def _rate_limit(self):
        """Apply rate limiting to API requests"""
        current_time = time.time()
        time_since_last_request = current_time - self.last_request_time

        if time_since_last_request < self.min_request_interval:
            time.sleep(self.min_request_interval - time_since_last_request)

        self.last_request_time = time.time()

    def _get_cached(self, key: str, max_age_hours: int = 24) -> Optional[Dict]:
        """Get cached data if available and not expired"""
        if key in self.cache:
            cached_data = self.cache[key]
            cached_time = datetime.fromisoformat(cached_data.get("timestamp", "2000-01-01"))

            if datetime.now() - cached_time < timedelta(hours=max_age_hours):
                return cached_data.get("data")

        return None

    def _set_cached(self, key: str, data: Dict):
        """Cache data with timestamp"""
        self.cache[key] = {
            "timestamp": datetime.now().isoformat(),
            "data": data
        }
        self.save_cache()

    def lookup_cve(self, cve_id: str) -> Optional[Dict]:
        """
        Look up CVE details by ID

        Args:
            cve_id: CVE identifier (e.g., CVE-2021-44228)

        Returns:
            CVE details including description, CVSS, references
        """
        if not self.enabled:
            return None

        # Check cache
        cache_key = f"cve_{cve_id}"
        cached = self._get_cached(cache_key)
        if cached:
            return cached

        try:
            # Try NVD API first
            self._rate_limit()
            url = f"{self.NVD_API_URL}?cveId={cve_id}"

            response = requests.get(url, timeout=10)

            if response.status_code == 200:
                data = response.json()

                if data.get("vulnerabilities"):
                    vuln = data["vulnerabilities"][0]["cve"]

                    cve_data = {
                        "id": cve_id,
                        "description": vuln.get("descriptions", [{}])[0].get("value", ""),
                        "published": vuln.get("published", ""),
                        "modified": vuln.get("lastModified", ""),
                        "cvss_v3": {},
                        "cvss_v2": {},
                        "references": [],
                        "cwe": []
                    }

                    # Extract CVSS scores
                    metrics = vuln.get("metrics", {})
                    if "cvssMetricV31" in metrics:
                        cvss = metrics["cvssMetricV31"][0]["cvssData"]
                        cve_data["cvss_v3"] = {
                            "score": cvss.get("baseScore", 0),
                            "severity": cvss.get("baseSeverity", ""),
                            "vector": cvss.get("vectorString", "")
                        }

                    if "cvssMetricV2" in metrics:
                        cvss = metrics["cvssMetricV2"][0]["cvssData"]
                        cve_data["cvss_v2"] = {
                            "score": cvss.get("baseScore", 0),
                            "severity": cvss.get("baseSeverity", ""),
                            "vector": cvss.get("vectorString", "")
                        }

                    # Extract references
                    for ref in vuln.get("references", []):
                        cve_data["references"].append({
                            "url": ref.get("url", ""),
                            "source": ref.get("source", "")
                        })

                    # Extract CWE
                    for weakness in vuln.get("weaknesses", []):
                        for desc in weakness.get("description", []):
                            cve_data["cwe"].append(desc.get("value", ""))

                    # Cache result
                    self._set_cached(cache_key, cve_data)

                    return cve_data

        except Exception as e:
            print(f"Error looking up CVE: {e}")

        return None

    def search_vulnerabilities(self, keyword: str, limit: int = 10) -> List[Dict]:
        """
        Search for vulnerabilities by keyword

        Args:
            keyword: Search term (product name, vendor, etc.)
            limit: Maximum number of results

        Returns:
            List of vulnerability summaries
        """
        if not self.enabled:
            return []

        cache_key = f"search_{keyword}_{limit}"
        cached = self._get_cached(cache_key, max_age_hours=6)
        if cached:
            return cached

        try:
            self._rate_limit()
            url = f"{self.NVD_API_URL}?keywordSearch={keyword}&resultsPerPage={limit}"

            response = requests.get(url, timeout=15)

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []

                for item in data.get("vulnerabilities", []):
                    vuln = item.get("cve", {})

                    vuln_data = {
                        "id": vuln.get("id", ""),
                        "description": vuln.get("descriptions", [{}])[0].get("value", "")[:200] + "...",
                        "published": vuln.get("published", ""),
                        "cvss_score": 0,
                        "severity": "UNKNOWN"
                    }

                    # Get CVSS score
                    metrics = vuln.get("metrics", {})
                    if "cvssMetricV31" in metrics:
                        cvss = metrics["cvssMetricV31"][0]["cvssData"]
                        vuln_data["cvss_score"] = cvss.get("baseScore", 0)
                        vuln_data["severity"] = cvss.get("baseSeverity", "UNKNOWN")

                    vulnerabilities.append(vuln_data)

                self._set_cached(cache_key, vulnerabilities)
                return vulnerabilities

        except Exception as e:
            print(f"Error searching vulnerabilities: {e}")

        return []

    def get_recent_vulnerabilities(self, days: int = 7, limit: int = 20) -> List[Dict]:
        """
        Get recently published vulnerabilities

        Args:
            days: Number of days to look back
            limit: Maximum number of results

        Returns:
            List of recent vulnerabilities
        """
        if not self.enabled:
            return []

        cache_key = f"recent_{days}_{limit}"
        cached = self._get_cached(cache_key, max_age_hours=1)
        if cached:
            return cached

        try:
            # Calculate date range
            end_date = datetime.now()
            start_date = end_date - timedelta(days=days)

            self._rate_limit()
            url = f"{self.NVD_API_URL}?pubStartDate={start_date.isoformat()}&pubEndDate={end_date.isoformat()}&resultsPerPage={limit}"

            response = requests.get(url, timeout=15)

            if response.status_code == 200:
                data = response.json()
                vulnerabilities = []

                for item in data.get("vulnerabilities", []):
                    vuln = item.get("cve", {})

                    vuln_data = {
                        "id": vuln.get("id", ""),
                        "description": vuln.get("descriptions", [{}])[0].get("value", "")[:200] + "...",
                        "published": vuln.get("published", ""),
                        "cvss_score": 0,
                        "severity": "UNKNOWN"
                    }

                    metrics = vuln.get("metrics", {})
                    if "cvssMetricV31" in metrics:
                        cvss = metrics["cvssMetricV31"][0]["cvssData"]
                        vuln_data["cvss_score"] = cvss.get("baseScore", 0)
                        vuln_data["severity"] = cvss.get("baseSeverity", "UNKNOWN")

                    vulnerabilities.append(vuln_data)

                self._set_cached(cache_key, vulnerabilities)
                return vulnerabilities

        except Exception as e:
            print(f"Error getting recent vulnerabilities: {e}")

        return []

    def check_service_vulnerabilities(self, service_name: str, version: str = "") -> List[Dict]:
        """
        Check for known vulnerabilities in a service

        Args:
            service_name: Service/product name
            version: Version number (optional)

        Returns:
            List of known vulnerabilities
        """
        search_term = service_name
        if version:
            search_term += f" {version}"

        return self.search_vulnerabilities(search_term)

    def get_exploit_availability(self, cve_id: str) -> Dict:
        """
        Check if exploits are available for a CVE

        Args:
            cve_id: CVE identifier

        Returns:
            Dict with exploit availability information
        """
        cache_key = f"exploit_{cve_id}"
        cached = self._get_cached(cache_key, max_age_hours=24)
        if cached:
            return cached

        exploit_info = {
            "cve_id": cve_id,
            "exploits_available": False,
            "public_exploits": [],
            "metasploit_modules": []
        }

        # Get CVE details which include references
        cve_data = self.lookup_cve(cve_id)
        if cve_data:
            references = cve_data.get("references", [])

            for ref in references:
                url = ref.get("url", "").lower()

                if "exploit-db.com" in url or "exploitdb.com" in url:
                    exploit_info["exploits_available"] = True
                    exploit_info["public_exploits"].append(ref.get("url"))

                elif "github.com" in url and "exploit" in url:
                    exploit_info["exploits_available"] = True
                    exploit_info["public_exploits"].append(ref.get("url"))

        self._set_cached(cache_key, exploit_info)
        return exploit_info

    def get_severity_rating(self, cvss_score: float) -> str:
        """
        Get severity rating based on CVSS score

        Args:
            cvss_score: CVSS base score

        Returns:
            Severity rating string
        """
        if cvss_score >= 9.0:
            return "CRITICAL"
        elif cvss_score >= 7.0:
            return "HIGH"
        elif cvss_score >= 4.0:
            return "MEDIUM"
        elif cvss_score > 0:
            return "LOW"
        else:
            return "NONE"

    def analyze_scan_results(self, scan_results: List[Dict]) -> Dict:
        """
        Analyze scan results and enrich with vulnerability data

        Args:
            scan_results: List of scan findings with service info

        Returns:
            Analysis with vulnerability information
        """
        analysis = {
            "total_services": len(scan_results),
            "vulnerable_services": 0,
            "total_vulnerabilities": 0,
            "critical_count": 0,
            "high_count": 0,
            "medium_count": 0,
            "low_count": 0,
            "findings": []
        }

        for service in scan_results:
            service_name = service.get("name", "")
            version = service.get("version", "")

            if service_name:
                vulns = self.check_service_vulnerabilities(service_name, version)

                if vulns:
                    analysis["vulnerable_services"] += 1
                    analysis["total_vulnerabilities"] += len(vulns)

                    for vuln in vulns:
                        severity = vuln.get("severity", "UNKNOWN")

                        if severity == "CRITICAL":
                            analysis["critical_count"] += 1
                        elif severity == "HIGH":
                            analysis["high_count"] += 1
                        elif severity == "MEDIUM":
                            analysis["medium_count"] += 1
                        elif severity == "LOW":
                            analysis["low_count"] += 1

                    analysis["findings"].append({
                        "service": service_name,
                        "version": version,
                        "vulnerabilities": vulns
                    })

        return analysis

    def clear_cache(self):
        """Clear vulnerability cache"""
        self.cache = {}
        self.save_cache()
